%利用最小二乘递推算法进行参数辨识
%单输入单输出系统：A(z^-1)y(t)=B(z^-1)u(t)+C(z^-1)e(t)
%其中A(z^-1)=1-2.851z^-1+2.717z^-2-0.865z^-3
%B(z^-1)=z^-1+z^-2+z^-3
%C(z^-1)=1+0.7z^-1+0.22z^-2
%e(t)服从N(0,1)分布
clear
clc

x=[0 1 0 1 1 0 1 1 1]; 	%寄存器初值，用来产生M序列
n=503; 				%脉冲数目
N=500;

%=====开始:输入数据：M序列=====%
for i=1:n
temp=xor(x(4),x(9));
M(i)=x(9);		   %M序列,500点
    for j=9:-1:2
    x(j)=x(j-1);
    end
x(1)=temp;
end
%=====结束:输入数据：M序列=====%

%=====开始:输入噪声：正态分布=====%
e=randn(1,N+3);
%=====结束:输入噪声：正态分布=====%

%=====开始:输入噪声：正态分布=====%
% v=randn(1,N+3);
% e=[];
% e(1)=v(1);
% e(2)=v(2);
% e(3)=v(3);
% for i=4:N
%     e(i)=0*e(i-1)+0*e(i-2)+v(i);
% end
%=====结束:输入噪声：正态分布=====%

%=****系统模型****=%
%y(t)-2.851*y(t-1)+2.717*y(t-2)-0.865*y(t-3)=u(t-1)+u(t-2)+u(t-3)+e(t)+0.7*e(t-1)+0.22*e(t-2);
%=****系统模型****=%
%=****辨识模型****=%
%y(t)=2.851*y(t-1)-2.717*y(t-2)+0.865*y(t-3)+u(t-1)+u(t-2)+u(t-3)+e(t)+0.7*e(t-1)+0.22*e(t-2);
%=****辨识模型****=%

%=====开始:输出数据：递推计算=====%
y=zeros(N,1);
y(1)=-1;
y(2)=0;
y(3)=1;
for t=4:N
    y(t)=2.851*y(t-1)-2.717*y(t-2)+0.865*y(t-3)+M(t-1)+M(t-2)+M(t-3)+e(t)+0.7*e(t-1)+0.22*e(t-2);
end
%=====结束:输出数据：递推计算=====%

%=====开始:递推：系统辨识=====%
% P=100*eye(6); 		%估计方差
% Pstore=zeros(6,N+1);
% Pstore(:,1)=[P(1,1),P(2,2),P(3,3),P(4,4),P(5,5),P(6,6)];
% Theta=zeros(6,N+1); 	%参数估计值
% Theta(:,1)=[3;3;3;3;3;3];	%参数估计初值
% K=[10;10;10;10;10;10];		%增益矩阵初值
% for i=4:N
%     h=[-y(i-1);-y(i-2);-y(i-3);M(i-1);M(i-2);M(i-3)];
%     K=P*h*inv(h'*P*h+1);
%     Theta(:,i-1)=Theta(:,i-2)+K*(y(i)-h'*Theta(:,i-2));
%     P=(eye(6)-K*h')*P;
%     Pstore(:,i-1)=[P(1,1),P(2,2),P(3,3),P(4,4),P(5,5),P(6,6)];
% end
% result=zeros(6,1);
% result(1,1)=Theta(1,500)
% result(2,1)=Theta(2,500)
% result(3,1)=Theta(3,500)
% result(4,1)=Theta(4,500)
% result(5,1)=Theta(5,500)
% result(6,1)=Theta(6,500)
%=====结束:递推：系统辨识=====%

%=====开始:增广：系统辨识=====%
P=100*eye(9);       %估计方差
Pstore=zeros(9,N+1);
Pstore(:,1)=[P(1,1),P(2,2),P(3,3),P(4,4),P(5,5),P(6,6),P(7,7),P(8,8),P(9,9)];
Theta=zeros(9,N+1);
Theta(:,1)=[3;3;3;3;3;3;3;3;3];
K=[10;10;10;10;10;10;10;10;10];
for i=4:N
    h=[-y(i-1);-y(i-2);-y(i-3);M(i-1);M(i-2);M(i-3);e(i);e(i-1);e(i-2)];
    K=P*h*inv(h'*P*h+1);
    Theta(:,i-1)=Theta(:,i-2)+K*(y(i)-h'*Theta(:,i-2));
    P=(eye(9)-K*h')*P;
    Pstore(:,i-1)=[P(1,1),P(2,2),P(3,3),P(4,4),P(5,5),P(6,6),P(7,7),P(8,8),P(9,9)];
end
%=====结束:增广：系统辨识=====%

%=====开始:作图：参数辨识结果=====%
i=1:N+1;
figure(1)
% plot(i,Theta(1,:),i,Theta(2,:),i,Theta(3,:),i,Theta(4,:),i,Theta(5,:),i,Theta(6,:))
plot(i,Theta(1,:),i,Theta(2,:),i,Theta(3,:),i,Theta(4,:),i,Theta(5,:),i,Theta(6,:),i,Theta(7,:),i,Theta(8,:),i,Theta(9,:))
title('待估参数过渡过程');
%=====结束:作图：参数辨识结果=====%

%=====开始:作图：方差辨识结果=====%
figure(2)
% plot(i,Pstore(1,:),i,Pstore(2,:),i,Pstore(3,:),i,Pstore(4,:),i,Pstore(5,:),i,Pstore(6,:))
plot(i,Pstore(1,:),i,Pstore(2,:),i,Pstore(3,:),i,Pstore(4,:),i,Pstore(5,:),i,Pstore(6,:),i,Pstore(7,:),i,Pstore(8,:),i,Pstore(9,:))
axis([0 15 0 100]);
set(gca,'xtick',[0 3 6 9 12 15]);
set(gca,'ytick',[0 20 40 60 80 100]);
title('估计方差变化过程');
%=====结束:作图：方差辨识结果=====%

result=zeros(9,1);
result(1,1)=Theta(1,499);
result(2,1)=Theta(2,499);
result(3,1)=Theta(3,499);
result(4,1)=Theta(4,499);
result(5,1)=Theta(5,499);
result(6,1)=Theta(6,499);
result(7,1)=Theta(7,499);
result(8,1)=Theta(8,499);
result(9,1)=Theta(9,499)